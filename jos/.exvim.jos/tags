!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALT	.\lab\kern\console.c	218;"	d	file:
AR	.\lab\GNUmakefile	/^AR	:= $(GCCPREFIX)ar$/;"	m
ARRAY_SIZE	.\lab\inc\types.h	70;"	d
AS	.\lab\GNUmakefile	/^AS	:= $(GCCPREFIX)as$/;"	m
ASM	.\lab\lib\string.c	9;"	d	file:
BUFLEN	.\lab\lib\readline.c	4;"	d	file:
C	.\lab\kern\console.c	285;"	d	file:
CAPSLOCK	.\lab\kern\console.c	220;"	d	file:
CC	.\lab\GNUmakefile	/^CC	:= $(GCCPREFIX)gcc -pipe$/;"	m
CFLAGS	.\lab\GNUmakefile	/^CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MD$/;"	m
CGA_BASE	.\lab\kern\console.h	13;"	d
CGA_BUF	.\lab\kern\console.h	14;"	d
CHECKSUM	.\lab\kern\entry.S	/^#define CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS))$/;"	d
CMDBUF_SIZE	.\lab\kern\monitor.c	14;"	d	file:
CMDBYTE	.\lab\inc\kbdreg.h	60;"	d
COLORS	.\lab\gradelib.py	/^COLORS = {"default": "\\033[0m", "red": "\\033[31m", "green": "\\033[32m"}$/;"	v
COM1	.\lab\kern\console.c	26;"	d	file:
COM_DLL	.\lab\kern\console.c	30;"	d	file:
COM_DLM	.\lab\kern\console.c	31;"	d	file:
COM_FCR	.\lab\kern\console.c	35;"	d	file:
COM_IER	.\lab\kern\console.c	32;"	d	file:
COM_IER_RDI	.\lab\kern\console.c	33;"	d	file:
COM_IIR	.\lab\kern\console.c	34;"	d	file:
COM_LCR	.\lab\kern\console.c	36;"	d	file:
COM_LCR_DLAB	.\lab\kern\console.c	37;"	d	file:
COM_LCR_WLEN8	.\lab\kern\console.c	38;"	d	file:
COM_LSR	.\lab\kern\console.c	43;"	d	file:
COM_LSR_DATA	.\lab\kern\console.c	44;"	d	file:
COM_LSR_TSRE	.\lab\kern\console.c	46;"	d	file:
COM_LSR_TXRDY	.\lab\kern\console.c	45;"	d	file:
COM_MCR	.\lab\kern\console.c	39;"	d	file:
COM_MCR_DTR	.\lab\kern\console.c	41;"	d	file:
COM_MCR_OUT2	.\lab\kern\console.c	42;"	d	file:
COM_MCR_RTS	.\lab\kern\console.c	40;"	d	file:
COM_RX	.\lab\kern\console.c	28;"	d	file:
COM_TX	.\lab\kern\console.c	29;"	d	file:
CONSBUFSIZE	.\lab\kern\console.c	385;"	d	file:
CR0_AM	.\lab\inc\mmu.h	86;"	d
CR0_CD	.\lab\inc\mmu.h	88;"	d
CR0_EM	.\lab\inc\mmu.h	81;"	d
CR0_ET	.\lab\inc\mmu.h	83;"	d
CR0_MP	.\lab\inc\mmu.h	80;"	d
CR0_NE	.\lab\inc\mmu.h	84;"	d
CR0_NW	.\lab\inc\mmu.h	87;"	d
CR0_PE	.\lab\inc\mmu.h	79;"	d
CR0_PG	.\lab\inc\mmu.h	89;"	d
CR0_TS	.\lab\inc\mmu.h	82;"	d
CR0_WP	.\lab\inc\mmu.h	85;"	d
CR4_DE	.\lab\inc\mmu.h	94;"	d
CR4_MCE	.\lab\inc\mmu.h	92;"	d
CR4_PCE	.\lab\inc\mmu.h	91;"	d
CR4_PSE	.\lab\inc\mmu.h	93;"	d
CR4_PVI	.\lab\inc\mmu.h	96;"	d
CR4_TSD	.\lab\inc\mmu.h	95;"	d
CR4_VME	.\lab\inc\mmu.h	97;"	d
CRT_COLS	.\lab\kern\console.h	17;"	d
CRT_ROWS	.\lab\kern\console.h	16;"	d
CRT_SIZE	.\lab\kern\console.h	18;"	d
CTL	.\lab\kern\console.c	217;"	d	file:
CURRENT_TEST	.\lab\gradelib.py	/^CURRENT_TEST = None$/;"	v
Command	.\lab\kern\monitor.c	/^struct Command {$/;"	s	file:
Command::desc	.\lab\kern\monitor.c	/^	const char *desc;$/;"	m	struct:Command	file:	access:public
Command::func	.\lab\kern\monitor.c	/^	int (*func)(int argc, char** argv, struct Trapframe* tf);$/;"	m	struct:Command	file:	access:public
Command::name	.\lab\kern\monitor.c	/^	const char *name;$/;"	m	struct:Command	file:	access:public
E0ESC	.\lab\kern\console.c	224;"	d	file:
ELFHDR	.\lab\boot\main.c	33;"	d	file:
ELF_MAGIC	.\lab\inc\elf.h	4;"	d
ELF_PROG_FLAG_EXEC	.\lab\inc\elf.h	52;"	d
ELF_PROG_FLAG_READ	.\lab\inc\elf.h	54;"	d
ELF_PROG_FLAG_WRITE	.\lab\inc\elf.h	53;"	d
ELF_PROG_LOAD	.\lab\inc\elf.h	49;"	d
ELF_SHN_UNDEF	.\lab\inc\elf.h	63;"	d
ELF_SHT_NULL	.\lab\inc\elf.h	57;"	d
ELF_SHT_PROGBITS	.\lab\inc\elf.h	58;"	d
ELF_SHT_STRTAB	.\lab\inc\elf.h	60;"	d
ELF_SHT_SYMTAB	.\lab\inc\elf.h	59;"	d
EXTPHYSMEM	.\lab\inc\memlayout.h	93;"	d
E_BAD_ENV	.\lab\inc\error.h	/^	E_BAD_ENV	,	\/\/ Environment doesn't exist or otherwise$/;"	e	enum:__anon1
E_FAULT	.\lab\inc\error.h	/^	E_FAULT		,	\/\/ Memory fault$/;"	e	enum:__anon1
E_INVAL	.\lab\inc\error.h	/^	E_INVAL		,	\/\/ Invalid parameter$/;"	e	enum:__anon1
E_NO_FREE_ENV	.\lab\inc\error.h	/^	E_NO_FREE_ENV	,	\/\/ Attempt to create a new environment beyond$/;"	e	enum:__anon1
E_NO_MEM	.\lab\inc\error.h	/^	E_NO_MEM	,	\/\/ Request failed due to memory shortage$/;"	e	enum:__anon1
E_UNSPECIFIED	.\lab\inc\error.h	/^	E_UNSPECIFIED	= 1,	\/\/ Unspecified or unknown problem$/;"	e	enum:__anon1
Eipdebuginfo	.\lab\kern\kdebug.h	/^struct Eipdebuginfo {$/;"	s
Eipdebuginfo::eip_file	.\lab\kern\kdebug.h	/^	const char *eip_file;		\/\/ Source code filename for EIP$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_addr	.\lab\kern\kdebug.h	/^	uintptr_t eip_fn_addr;		\/\/ Address of start of function$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_name	.\lab\kern\kdebug.h	/^	const char *eip_fn_name;	\/\/ Name of function containing EIP$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_namelen	.\lab\kern\kdebug.h	/^	int eip_fn_namelen;		\/\/ Length of function name$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_narg	.\lab\kern\kdebug.h	/^	int eip_fn_narg;		\/\/ Number of function arguments$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_line	.\lab\kern\kdebug.h	/^	int eip_line;			\/\/ Source code linenumber for EIP$/;"	m	struct:Eipdebuginfo	access:public
Elf	.\lab\inc\elf.h	/^struct Elf {$/;"	s
Elf::e_ehsize	.\lab\inc\elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf	access:public
Elf::e_elf	.\lab\inc\elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf	access:public
Elf::e_entry	.\lab\inc\elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf	access:public
Elf::e_flags	.\lab\inc\elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf	access:public
Elf::e_machine	.\lab\inc\elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf	access:public
Elf::e_magic	.\lab\inc\elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf	access:public
Elf::e_phentsize	.\lab\inc\elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf	access:public
Elf::e_phnum	.\lab\inc\elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf	access:public
Elf::e_phoff	.\lab\inc\elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf	access:public
Elf::e_shentsize	.\lab\inc\elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf	access:public
Elf::e_shnum	.\lab\inc\elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf	access:public
Elf::e_shoff	.\lab\inc\elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf	access:public
Elf::e_shstrndx	.\lab\inc\elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf	access:public
Elf::e_type	.\lab\inc\elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf	access:public
Elf::e_version	.\lab\inc\elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf	access:public
FEC_PR	.\lab\inc\mmu.h	123;"	d
FEC_U	.\lab\inc\mmu.h	125;"	d
FEC_WR	.\lab\inc\mmu.h	124;"	d
FL_AC	.\lab\inc\mmu.h	117;"	d
FL_AF	.\lab\inc\mmu.h	102;"	d
FL_CF	.\lab\inc\mmu.h	100;"	d
FL_DF	.\lab\inc\mmu.h	107;"	d
FL_ID	.\lab\inc\mmu.h	120;"	d
FL_IF	.\lab\inc\mmu.h	106;"	d
FL_IOPL_0	.\lab\inc\mmu.h	110;"	d
FL_IOPL_1	.\lab\inc\mmu.h	111;"	d
FL_IOPL_2	.\lab\inc\mmu.h	112;"	d
FL_IOPL_3	.\lab\inc\mmu.h	113;"	d
FL_IOPL_MASK	.\lab\inc\mmu.h	109;"	d
FL_NT	.\lab\inc\mmu.h	114;"	d
FL_OF	.\lab\inc\mmu.h	108;"	d
FL_PF	.\lab\inc\mmu.h	101;"	d
FL_RF	.\lab\inc\mmu.h	115;"	d
FL_SF	.\lab\inc\mmu.h	104;"	d
FL_TF	.\lab\inc\mmu.h	105;"	d
FL_VIF	.\lab\inc\mmu.h	118;"	d
FL_VIP	.\lab\inc\mmu.h	119;"	d
FL_VM	.\lab\inc\mmu.h	116;"	d
FL_ZF	.\lab\inc\mmu.h	103;"	d
GCCPREFIX	.\lab\GNUmakefile	/^GCCPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
GCC_LIB	.\lab\GNUmakefile	/^GCC_LIB := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)$/;"	m
GDBClient	.\lab\gradelib.py	/^class GDBClient(object):$/;"	c	inherits:object
GDBPORT	.\lab\GNUmakefile	/^GDBPORT	:= $(shell expr `id -u` % 5000 + 25000)$/;"	m
GD_KD	.\lab\inc\memlayout.h	16;"	d
GD_KT	.\lab\inc\memlayout.h	15;"	d
GD_TSS0	.\lab\inc\memlayout.h	19;"	d
GD_UD	.\lab\inc\memlayout.h	18;"	d
GD_UT	.\lab\inc\memlayout.h	17;"	d
Gatedesc	.\lab\inc\mmu.h	/^struct Gatedesc {$/;"	s
Gatedesc::gd_args	.\lab\inc\mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_dpl	.\lab\inc\mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_off_15_0	.\lab\inc\mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_off_31_16	.\lab\inc\mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_p	.\lab\inc\mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_rsv1	.\lab\inc\mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_s	.\lab\inc\mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_sel	.\lab\inc\mmu.h	/^	unsigned gd_sel : 16;        \/\/ segment selector$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_type	.\lab\inc\mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc	access:public
IMAGES	.\lab\GNUmakefile	/^IMAGES = $(OBJDIR)\/kern\/kernel.img$/;"	m
IOPHYSMEM	.\lab\inc\memlayout.h	92;"	d
JOS_INC_ASSERT_H	.\lab\inc\assert.h	4;"	d
JOS_INC_ELF_H	.\lab\inc\elf.h	2;"	d
JOS_INC_ERROR_H	.\lab\inc\error.h	4;"	d
JOS_INC_MEMLAYOUT_H	.\lab\inc\memlayout.h	2;"	d
JOS_INC_MMU_H	.\lab\inc\mmu.h	2;"	d
JOS_INC_STDARG_H	.\lab\inc\stdarg.h	4;"	d
JOS_INC_STDIO_H	.\lab\inc\stdio.h	2;"	d
JOS_INC_STRING_H	.\lab\inc\string.h	2;"	d
JOS_INC_TYPES_H	.\lab\inc\types.h	2;"	d
JOS_INC_X86_H	.\lab\inc\x86.h	2;"	d
JOS_KBDREG_H	.\lab\inc\kbdreg.h	2;"	d
JOS_KERN_KDEBUG_H	.\lab\kern\kdebug.h	2;"	d
JOS_KERN_MONITOR_H	.\lab\kern\monitor.h	2;"	d
JOS_STAB_H	.\lab\inc\stab.h	2;"	d
KBCMDP	.\lab\inc\kbdreg.h	29;"	d
KBC_AUXDISABLE	.\lab\inc\kbdreg.h	32;"	d
KBC_AUXECHO	.\lab\inc\kbdreg.h	36;"	d
KBC_AUXENABLE	.\lab\inc\kbdreg.h	33;"	d
KBC_AUXTEST	.\lab\inc\kbdreg.h	34;"	d
KBC_AUXWRITE	.\lab\inc\kbdreg.h	37;"	d
KBC_DISABLE	.\lab\inc\kbdreg.h	66;"	d
KBC_ECHO	.\lab\inc\kbdreg.h	71;"	d
KBC_ENABLE	.\lab\inc\kbdreg.h	67;"	d
KBC_KBDDISABLE	.\lab\inc\kbdreg.h	40;"	d
KBC_KBDECHO	.\lab\inc\kbdreg.h	35;"	d
KBC_KBDENABLE	.\lab\inc\kbdreg.h	41;"	d
KBC_KBDTEST	.\lab\inc\kbdreg.h	39;"	d
KBC_MODEIND	.\lab\inc\kbdreg.h	70;"	d
KBC_PULSE0	.\lab\inc\kbdreg.h	42;"	d
KBC_PULSE1	.\lab\inc\kbdreg.h	43;"	d
KBC_PULSE2	.\lab\inc\kbdreg.h	44;"	d
KBC_PULSE3	.\lab\inc\kbdreg.h	45;"	d
KBC_RAMREAD	.\lab\inc\kbdreg.h	30;"	d
KBC_RAMWRITE	.\lab\inc\kbdreg.h	31;"	d
KBC_RESEND	.\lab\inc\kbdreg.h	64;"	d
KBC_RESET	.\lab\inc\kbdreg.h	63;"	d
KBC_SELFTEST	.\lab\inc\kbdreg.h	38;"	d
KBC_SETDEFAULT	.\lab\inc\kbdreg.h	65;"	d
KBC_SETTABLE	.\lab\inc\kbdreg.h	69;"	d
KBC_TYPEMATIC	.\lab\inc\kbdreg.h	68;"	d
KBDATAP	.\lab\inc\kbdreg.h	47;"	d
KBOUTP	.\lab\inc\kbdreg.h	48;"	d
KBR_ACK	.\lab\inc\kbdreg.h	76;"	d
KBR_BREAK	.\lab\inc\kbdreg.h	79;"	d
KBR_ECHO	.\lab\inc\kbdreg.h	81;"	d
KBR_EXTENDED	.\lab\inc\kbdreg.h	74;"	d
KBR_FAILURE	.\lab\inc\kbdreg.h	78;"	d
KBR_OVERRUN	.\lab\inc\kbdreg.h	77;"	d
KBR_RESEND	.\lab\inc\kbdreg.h	75;"	d
KBR_RSTDONE	.\lab\inc\kbdreg.h	80;"	d
KBSTATP	.\lab\inc\kbdreg.h	19;"	d
KBS_DIB	.\lab\inc\kbdreg.h	20;"	d
KBS_IBF	.\lab\inc\kbdreg.h	21;"	d
KBS_NOSEC	.\lab\inc\kbdreg.h	24;"	d
KBS_OCMD	.\lab\inc\kbdreg.h	23;"	d
KBS_PERR	.\lab\inc\kbdreg.h	27;"	d
KBS_RERR	.\lab\inc\kbdreg.h	26;"	d
KBS_TERR	.\lab\inc\kbdreg.h	25;"	d
KBS_WARM	.\lab\inc\kbdreg.h	22;"	d
KC8_CPU	.\lab\inc\kbdreg.h	57;"	d
KC8_IGNSEC	.\lab\inc\kbdreg.h	56;"	d
KC8_KDISABLE	.\lab\inc\kbdreg.h	55;"	d
KC8_KENABLE	.\lab\inc\kbdreg.h	59;"	d
KC8_MDISABLE	.\lab\inc\kbdreg.h	54;"	d
KC8_MENABLE	.\lab\inc\kbdreg.h	58;"	d
KC8_TRANS	.\lab\inc\kbdreg.h	53;"	d
KERNBASE	.\lab\inc\memlayout.h	87;"	d
KERN_CFLAGS	.\lab\GNUmakefile	/^KERN_CFLAGS := $(CFLAGS) -DJOS_KERNEL -gstabs$/;"	m
KEY_DEL	.\lab\inc\kbdreg.h	14;"	d
KEY_DN	.\lab\inc\kbdreg.h	8;"	d
KEY_END	.\lab\inc\kbdreg.h	6;"	d
KEY_HOME	.\lab\inc\kbdreg.h	5;"	d
KEY_INS	.\lab\inc\kbdreg.h	13;"	d
KEY_LF	.\lab\inc\kbdreg.h	9;"	d
KEY_PGDN	.\lab\inc\kbdreg.h	12;"	d
KEY_PGUP	.\lab\inc\kbdreg.h	11;"	d
KEY_RT	.\lab\inc\kbdreg.h	10;"	d
KEY_UP	.\lab\inc\kbdreg.h	7;"	d
KSTACKTOP	.\lab\inc\memlayout.h	96;"	d
KSTKGAP	.\lab\inc\memlayout.h	98;"	d
KSTKSIZE	.\lab\inc\memlayout.h	97;"	d
K_LDCMDBYTE	.\lab\inc\kbdreg.h	51;"	d
K_RDCMDBYTE	.\lab\inc\kbdreg.h	50;"	d
LAB	.\lab\conf\lab.mk	/^LAB=1$/;"	m
LABSETUP	.\lab\GNUmakefile	/^LABSETUP ?= .\/$/;"	m
LD	.\lab\GNUmakefile	/^LD	:= $(GCCPREFIX)ld$/;"	m
LDFLAGS	.\lab\GNUmakefile	/^LDFLAGS := -m elf_i386$/;"	m
MAKE_TIMESTAMP	.\lab\gradelib.py	/^MAKE_TIMESTAMP = 0$/;"	v
MAX	.\lab\inc\types.h	49;"	d
MAXARGS	.\lab\kern\monitor.c	69;"	d	file:
MAXERROR	.\lab\inc\error.h	/^	MAXERROR$/;"	e	enum:__anon1
MIN	.\lab\inc\types.h	43;"	d
MMIOBASE	.\lab\inc\memlayout.h	102;"	d
MMIOLIM	.\lab\inc\memlayout.h	101;"	d
MONO_BASE	.\lab\kern\console.h	11;"	d
MONO_BUF	.\lab\kern\console.h	12;"	d
MULTIBOOT_HEADER_FLAGS	.\lab\kern\entry.S	/^#define MULTIBOOT_HEADER_FLAGS (0)$/;"	d
MULTIBOOT_HEADER_MAGIC	.\lab\kern\entry.S	/^#define MULTIBOOT_HEADER_MAGIC (0x1BADB002)$/;"	d
NATIVE_CFLAGS	.\lab\GNUmakefile	/^NATIVE_CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -I$(TOP) -MD -Wall$/;"	m
NCC	.\lab\GNUmakefile	/^NCC	:= gcc $(CC_VER) -pipe$/;"	m
NM	.\lab\GNUmakefile	/^NM	:= $(GCCPREFIX)nm$/;"	m
NO	.\lab\kern\console.c	214;"	d	file:
NPDENTRIES	.\lab\inc\mmu.h	45;"	d
NPTENTRIES	.\lab\inc\mmu.h	46;"	d
NULL	.\lab\inc\stdio.h	7;"	d
NULL	.\lab\inc\types.h	5;"	d
NUMLOCK	.\lab\kern\console.c	221;"	d	file:
N_BCOMM	.\lab\inc\stab.h	37;"	d
N_BINCL	.\lab\inc\stab.h	29;"	d
N_BSLINE	.\lab\inc\stab.h	25;"	d
N_DSLINE	.\lab\inc\stab.h	24;"	d
N_ECOML	.\lab\inc\stab.h	39;"	d
N_ECOMM	.\lab\inc\stab.h	38;"	d
N_EINCL	.\lab\inc\stab.h	32;"	d
N_ENTRY	.\lab\inc\stab.h	33;"	d
N_EXCL	.\lab\inc\stab.h	35;"	d
N_FNAME	.\lab\inc\stab.h	16;"	d
N_FUN	.\lab\inc\stab.h	17;"	d
N_GSYM	.\lab\inc\stab.h	15;"	d
N_LBRAC	.\lab\inc\stab.h	34;"	d
N_LCSYM	.\lab\inc\stab.h	19;"	d
N_LENG	.\lab\inc\stab.h	40;"	d
N_LSYM	.\lab\inc\stab.h	28;"	d
N_MAIN	.\lab\inc\stab.h	20;"	d
N_PC	.\lab\inc\stab.h	21;"	d
N_PSYM	.\lab\inc\stab.h	31;"	d
N_RBRAC	.\lab\inc\stab.h	36;"	d
N_RSYM	.\lab\inc\stab.h	22;"	d
N_SLINE	.\lab\inc\stab.h	23;"	d
N_SO	.\lab\inc\stab.h	27;"	d
N_SOL	.\lab\inc\stab.h	30;"	d
N_SSYM	.\lab\inc\stab.h	26;"	d
N_STSYM	.\lab\inc\stab.h	18;"	d
OBJCOPY	.\lab\GNUmakefile	/^OBJCOPY	:= $(GCCPREFIX)objcopy$/;"	m
OBJDIR	.\lab\GNUmakefile	/^OBJDIR := obj$/;"	m
OBJDIRS	.\lab\GNUmakefile	/^OBJDIRS :=$/;"	m
OBJDUMP	.\lab\GNUmakefile	/^OBJDUMP	:= $(GCCPREFIX)objdump$/;"	m
OptionParser	.\lab\gradelib.py	/^from optparse import OptionParser$/;"	i
PACKAGEDATE	.\lab\conf\lab.mk	/^PACKAGEDATE=Wed Sep 6 11:04:20 EDT 2017$/;"	m
PDX	.\lab\inc\mmu.h	33;"	d
PDXSHIFT	.\lab\inc\mmu.h	55;"	d
PERL	.\lab\GNUmakefile	/^PERL	:= perl$/;"	m
PFTEMP	.\lab\inc\memlayout.h	137;"	d
PGADDR	.\lab\inc\mmu.h	42;"	d
PGNUM	.\lab\inc\mmu.h	30;"	d
PGOFF	.\lab\inc\mmu.h	39;"	d
PGSHIFT	.\lab\inc\mmu.h	49;"	d
PGSIZE	.\lab\inc\mmu.h	48;"	d
PTE_A	.\lab\inc\mmu.h	63;"	d
PTE_ADDR	.\lab\inc\mmu.h	76;"	d
PTE_AVAIL	.\lab\inc\mmu.h	70;"	d
PTE_D	.\lab\inc\mmu.h	64;"	d
PTE_G	.\lab\inc\mmu.h	66;"	d
PTE_P	.\lab\inc\mmu.h	58;"	d
PTE_PCD	.\lab\inc\mmu.h	62;"	d
PTE_PS	.\lab\inc\mmu.h	65;"	d
PTE_PWT	.\lab\inc\mmu.h	61;"	d
PTE_SYSCALL	.\lab\inc\mmu.h	73;"	d
PTE_U	.\lab\inc\mmu.h	60;"	d
PTE_W	.\lab\inc\mmu.h	59;"	d
PTSHIFT	.\lab\inc\mmu.h	52;"	d
PTSIZE	.\lab\inc\mmu.h	51;"	d
PTX	.\lab\inc\mmu.h	36;"	d
PTXSHIFT	.\lab\inc\mmu.h	54;"	d
Popen	.\lab\gradelib.py	/^from subprocess import check_call, Popen$/;"	i
Proghdr	.\lab\inc\elf.h	/^struct Proghdr {$/;"	s
Proghdr::p_align	.\lab\inc\elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr	access:public
Proghdr::p_filesz	.\lab\inc\elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr	access:public
Proghdr::p_flags	.\lab\inc\elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr	access:public
Proghdr::p_memsz	.\lab\inc\elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr	access:public
Proghdr::p_offset	.\lab\inc\elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr	access:public
Proghdr::p_pa	.\lab\inc\elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr	access:public
Proghdr::p_type	.\lab\inc\elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr	access:public
Proghdr::p_va	.\lab\inc\elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr	access:public
Pseudodesc	.\lab\inc\mmu.h	/^struct Pseudodesc {$/;"	s
Pseudodesc::pd_base	.\lab\inc\mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc	access:public
Pseudodesc::pd_lim	.\lab\inc\mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc	access:public
QEMU	.\lab\GNUmakefile	/^QEMU := $(shell if which qemu >\/dev\/null 2>&1; \\$/;"	m
QEMU	.\lab\gradelib.py	/^class QEMU(object):$/;"	c	inherits:object
QEMUOPTS	.\lab\GNUmakefile	/^QEMUOPTS = -drive file=$(OBJDIR)\/kern\/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::$(GDBPORT)$/;"	m
RELOC	.\lab\kern\entry.S	/^#define	RELOC(x) ((x) - KERNBASE)$/;"	d
ROUNDDOWN	.\lab\inc\types.h	58;"	d
ROUNDUP	.\lab\inc\types.h	64;"	d
Runner	.\lab\gradelib.py	/^class Runner():$/;"	c	inherits:
SCROLLLOCK	.\lab\kern\console.c	222;"	d	file:
SECTSIZE	.\lab\boot\main.c	32;"	d	file:
SEG	.\lab\inc\mmu.h	142;"	d
SEG	.\lab\inc\mmu.h	172;"	d
SEG16	.\lab\inc\mmu.h	176;"	d
SEG_FAULT	.\lab\inc\mmu.h	170;"	d
SEG_NULL	.\lab\inc\mmu.h	139;"	d
SEG_NULL	.\lab\inc\mmu.h	168;"	d
SETCALLGATE	.\lab\inc\mmu.h	296;"	d
SETGATE	.\lab\inc\mmu.h	282;"	d
SHIFT	.\lab\kern\console.c	216;"	d	file:
SRL	.\lab\kern\entry.S	/^#define SRL(val, shamt)		(((val) >> (shamt)) & ~(-1 << (32 - (shamt))))$/;"	d
STA_A	.\lab\inc\mmu.h	189;"	d
STA_C	.\lab\inc\mmu.h	186;"	d
STA_E	.\lab\inc\mmu.h	185;"	d
STA_R	.\lab\inc\mmu.h	188;"	d
STA_W	.\lab\inc\mmu.h	187;"	d
STA_X	.\lab\inc\mmu.h	184;"	d
STS_CG16	.\lab\inc\mmu.h	195;"	d
STS_CG32	.\lab\inc\mmu.h	201;"	d
STS_IG16	.\lab\inc\mmu.h	197;"	d
STS_IG32	.\lab\inc\mmu.h	202;"	d
STS_LDT	.\lab\inc\mmu.h	193;"	d
STS_T16A	.\lab\inc\mmu.h	192;"	d
STS_T16B	.\lab\inc\mmu.h	194;"	d
STS_T32A	.\lab\inc\mmu.h	199;"	d
STS_T32B	.\lab\inc\mmu.h	200;"	d
STS_TG	.\lab\inc\mmu.h	196;"	d
STS_TG16	.\lab\inc\mmu.h	198;"	d
STS_TG32	.\lab\inc\mmu.h	203;"	d
Secthdr	.\lab\inc\elf.h	/^struct Secthdr {$/;"	s
Secthdr::sh_addr	.\lab\inc\elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_addralign	.\lab\inc\elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_entsize	.\lab\inc\elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_flags	.\lab\inc\elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_info	.\lab\inc\elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_link	.\lab\inc\elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_name	.\lab\inc\elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_offset	.\lab\inc\elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_size	.\lab\inc\elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_type	.\lab\inc\elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr	access:public
Segdesc	.\lab\inc\mmu.h	/^struct Segdesc {$/;"	s
Segdesc::sd_avl	.\lab\inc\mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_15_0	.\lab\inc\mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_23_16	.\lab\inc\mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_31_24	.\lab\inc\mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_db	.\lab\inc\mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc	access:public
Segdesc::sd_dpl	.\lab\inc\mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc	access:public
Segdesc::sd_g	.\lab\inc\mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc	access:public
Segdesc::sd_lim_15_0	.\lab\inc\mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc	access:public
Segdesc::sd_lim_19_16	.\lab\inc\mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc	access:public
Segdesc::sd_p	.\lab\inc\mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc	access:public
Segdesc::sd_rsv1	.\lab\inc\mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc	access:public
Segdesc::sd_s	.\lab\inc\mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc	access:public
Segdesc::sd_type	.\lab\inc\mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc	access:public
Stab	.\lab\inc\stab.h	/^struct Stab {$/;"	s
Stab::n_desc	.\lab\inc\stab.h	/^	uint16_t n_desc;        \/\/ description field$/;"	m	struct:Stab	access:public
Stab::n_other	.\lab\inc\stab.h	/^	uint8_t n_other;        \/\/ misc info (usually empty)$/;"	m	struct:Stab	access:public
Stab::n_strx	.\lab\inc\stab.h	/^	uint32_t n_strx;	\/\/ index into string table of name$/;"	m	struct:Stab	access:public
Stab::n_type	.\lab\inc\stab.h	/^	uint8_t n_type;         \/\/ type of symbol$/;"	m	struct:Stab	access:public
Stab::n_value	.\lab\inc\stab.h	/^	uintptr_t n_value;	\/\/ value of symbol$/;"	m	struct:Stab	access:public
TAR	.\lab\GNUmakefile	/^TAR	:= gtar$/;"	m
TEMP_ADDR	.\lab\user\sendpage.c	9;"	d	file:
TEMP_ADDR_CHILD	.\lab\user\sendpage.c	10;"	d	file:
TESTS	.\lab\gradelib.py	/^TESTS = []$/;"	v
TOP	.\lab\GNUmakefile	/^TOP = .$/;"	m
Taskstate	.\lab\inc\mmu.h	/^struct Taskstate {$/;"	s
Taskstate::ts_cr3	.\lab\inc\mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate	access:public
Taskstate::ts_cs	.\lab\inc\mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ds	.\lab\inc\mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eax	.\lab\inc\mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ebp	.\lab\inc\mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ebx	.\lab\inc\mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ecx	.\lab\inc\mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_edi	.\lab\inc\mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_edx	.\lab\inc\mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eflags	.\lab\inc\mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eip	.\lab\inc\mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate	access:public
Taskstate::ts_es	.\lab\inc\mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esi	.\lab\inc\mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp	.\lab\inc\mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp0	.\lab\inc\mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp1	.\lab\inc\mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp2	.\lab\inc\mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_fs	.\lab\inc\mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_gs	.\lab\inc\mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_iomb	.\lab\inc\mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ldt	.\lab\inc\mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_link	.\lab\inc\mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding1	.\lab\inc\mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding10	.\lab\inc\mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding2	.\lab\inc\mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding3	.\lab\inc\mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding4	.\lab\inc\mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding5	.\lab\inc\mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding6	.\lab\inc\mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding7	.\lab\inc\mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding8	.\lab\inc\mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding9	.\lab\inc\mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss	.\lab\inc\mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss0	.\lab\inc\mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss1	.\lab\inc\mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss2	.\lab\inc\mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_t	.\lab\inc\mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate	access:public
TerminateTest	.\lab\gradelib.py	/^class TerminateTest(Exception):$/;"	c	inherits:Exception
UENVS	.\lab\inc\memlayout.h	116;"	d
ULDFLAGS	.\lab\GNUmakefile	/^ULDFLAGS := -T user\/user.ld$/;"	m
ULIM	.\lab\inc\memlayout.h	104;"	d
UPAGES	.\lab\inc\memlayout.h	114;"	d
UPSTREAM	.\lab\GNUmakefile	/^UPSTREAM := $(shell git remote -v | grep "pdos.csail.mit.edu\/6.828\/2017\/jos.git (fetch)" | awk '{split($$0,a," "); print a[1]}')$/;"	m
USER_CFLAGS	.\lab\GNUmakefile	/^USER_CFLAGS := $(CFLAGS) -DJOS_USER -gstabs$/;"	m
USTABDATA	.\lab\inc\memlayout.h	139;"	d
USTACKTOP	.\lab\inc\memlayout.h	128;"	d
UTEMP	.\lab\inc\memlayout.h	134;"	d
UTEXT	.\lab\inc\memlayout.h	131;"	d
UTOP	.\lab\inc\memlayout.h	123;"	d
UVPT	.\lab\inc\memlayout.h	112;"	d
UXSTACKTOP	.\lab\inc\memlayout.h	125;"	d
V	.\lab\conf\env.mk	/^V = @$/;"	m
WEBSUB	.\lab\GNUmakefile	/^WEBSUB := https:\/\/6828.scripts.mit.edu\/2017\/handin.py$/;"	m
WHITESPACE	.\lab\kern\monitor.c	68;"	d	file:
_CONSOLE_H_	.\lab\kern\console.h	4;"	d
_GDBPORT	.\lab\gradelib.py	/^    _GDBPORT = None$/;"	v	class:QEMU
__all__	.\lab\gradelib.py	/^__all__ = []$/;"	v
__anon3::buf	.\lab\kern\console.c	/^	uint8_t buf[CONSBUFSIZE];$/;"	m	struct:__anon3	file:	access:public
__anon3::rpos	.\lab\kern\console.c	/^	uint32_t rpos;$/;"	m	struct:__anon3	file:	access:public
__anon3::wpos	.\lab\kern\console.c	/^	uint32_t wpos;$/;"	m	struct:__anon3	file:	access:public
__init__	.\lab\gradelib.py	/^    def __init__(self, *default_monitors):$/;"	m	class:Runner	access:public
__init__	.\lab\gradelib.py	/^    def __init__(self, *make_args):$/;"	m	class:QEMU	access:public
__init__	.\lab\gradelib.py	/^    def __init__(self, port, timeout=15):$/;"	m	class:GDBClient	access:public
__monitor_start	.\lab\gradelib.py	/^    def __monitor_start(self, output):$/;"	m	class:Runner	file:	access:private
__react	.\lab\gradelib.py	/^    def __react(self, reactors, timeout):$/;"	m	class:Runner	file:	access:private
__send	.\lab\gradelib.py	/^    def __send(self, cmd):$/;"	m	class:GDBClient	file:	access:private
__send_break	.\lab\gradelib.py	/^    def __send_break(self):$/;"	m	class:GDBClient	file:	access:private
_panic	.\lab\inc\assert.h	/^void _panic(const char*, int, const char*, ...) __attribute__((noreturn));$/;"	p	signature:(const char*, int, const char*, ...)
_panic	.\lab\kern\init.c	/^_panic(const char *file, int line, const char *fmt,...)$/;"	f	signature:(const char *file, int line, const char *fmt,...)
_start	.\lab\kern\entry.S	/^_start = RELOC(entry)$/;"	d
_warn	.\lab\inc\assert.h	/^void _warn(const char*, int, const char*, ...);$/;"	p	signature:(const char*, int, const char*, ...)
_warn	.\lab\kern\init.c	/^_warn(const char *file, int line, const char *fmt,...)$/;"	f	signature:(const char *file, int line, const char *fmt,...)
addr_6845	.\lab\kern\console.c	/^static unsigned addr_6845;$/;"	v	file:
assert	.\lab\inc\assert.h	14;"	d
assert_equal	.\lab\gradelib.py	/^def assert_equal(got, expect, msg=""):$/;"	f	access:public
assert_lines_match	.\lab\gradelib.py	/^def assert_lines_match(text, *regexps, **kw):$/;"	f	access:public
assert_lines_match_kw	.\lab\gradelib.py	/^    def assert_lines_match_kw(no=[]):$/;"	f	function:assert_lines_match	access:public
bool	.\lab\inc\types.h	/^typedef _Bool bool;$/;"	t
bootmain	.\lab\boot\main.c	/^bootmain(void)$/;"	f	signature:(void)
bootstack	.\lab\kern\entry.S	/^bootstack:$/;"	l
bootstacktop	.\lab\kern\entry.S	/^bootstacktop:$/;"	l
breakpoint	.\lab\gradelib.py	/^    def breakpoint(self, addr):$/;"	m	class:GDBClient	access:public
breakpoint	.\lab\inc\x86.h	/^breakpoint(void)$/;"	f	signature:(void)
buf	.\lab\kern\console.c	/^	uint8_t buf[CONSBUFSIZE];$/;"	m	struct:__anon3	file:	access:public
buf	.\lab\lib\printfmt.c	/^	char *buf;$/;"	m	struct:sprintbuf	file:	access:public
buf	.\lab\lib\readline.c	/^static char buf[BUFLEN];$/;"	v	file:
call_on_line	.\lab\gradelib.py	/^def call_on_line(regexp, callback):$/;"	f	access:public
cga_init	.\lab\kern\console.c	/^cga_init(void)$/;"	f	file:	signature:(void)
cga_putc	.\lab\kern\console.c	/^cga_putc(int c)$/;"	f	file:	signature:(int c)
charcode	.\lab\kern\console.c	/^static uint8_t *charcode[4] = {$/;"	v	file:
check_call	.\lab\gradelib.py	/^from subprocess import check_call, Popen$/;"	i
close	.\lab\gradelib.py	/^    def close(self):$/;"	m	class:GDBClient	access:public
cnt	.\lab\lib\printfmt.c	/^	int cnt;$/;"	m	struct:sprintbuf	file:	access:public
color	.\lab\gradelib.py	/^def color(name, text):$/;"	f	access:public
commands	.\lab\kern\monitor.c	/^static struct Command commands[] = {$/;"	v	typeref:struct:Command	file:
cons	.\lab\kern\console.c	/^} cons;$/;"	v	typeref:struct:__anon3	file:
cons_getc	.\lab\kern\console.c	/^cons_getc(void)$/;"	f	signature:(void)
cons_getc	.\lab\kern\console.h	/^int cons_getc(void);$/;"	p	signature:(void)
cons_init	.\lab\kern\console.c	/^cons_init(void)$/;"	f	signature:(void)
cons_init	.\lab\kern\console.h	/^void cons_init(void);$/;"	p	signature:(void)
cons_intr	.\lab\kern\console.c	/^cons_intr(int (*proc)(void))$/;"	f	file:	signature:(int (*proc)(void))
cons_intr	.\lab\kern\console.c	/^static void cons_intr(int (*proc)(void));$/;"	p	file:	signature:(int (*proc)(void))
cons_putc	.\lab\kern\console.c	/^cons_putc(int c)$/;"	f	file:	signature:(int c)
cons_putc	.\lab\kern\console.c	/^static void cons_putc(int c);$/;"	p	file:	signature:(int c)
cont	.\lab\gradelib.py	/^    def cont(self):$/;"	m	class:GDBClient	access:public
cprintf	.\lab\inc\stdio.h	/^int	cprintf(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
cprintf	.\lab\kern\printf.c	/^cprintf(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
cpuid	.\lab\inc\x86.h	/^cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)$/;"	f	signature:(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
cputchar	.\lab\inc\stdio.h	/^void	cputchar(int c);$/;"	p	signature:(int c)
cputchar	.\lab\kern\console.c	/^cputchar(int c)$/;"	f	signature:(int c)
crt_buf	.\lab\kern\console.c	/^static uint16_t *crt_buf;$/;"	v	file:
crt_pos	.\lab\kern\console.c	/^static uint16_t crt_pos;$/;"	v	file:
ctlmap	.\lab\kern\console.c	/^static uint8_t ctlmap[256] =$/;"	v	file:
debuginfo_eip	.\lab\kern\kdebug.c	/^debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)$/;"	f	signature:(uintptr_t addr, struct Eipdebuginfo *info)
debuginfo_eip	.\lab\kern\kdebug.h	/^int debuginfo_eip(uintptr_t eip, struct Eipdebuginfo *info);$/;"	p	signature:(uintptr_t eip, struct Eipdebuginfo *info)
delay	.\lab\kern\console.c	/^delay(void)$/;"	f	file:	signature:(void)
desc	.\lab\kern\monitor.c	/^	const char *desc;$/;"	m	struct:Command	file:	access:public
e_ehsize	.\lab\inc\elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf	access:public
e_elf	.\lab\inc\elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf	access:public
e_entry	.\lab\inc\elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf	access:public
e_flags	.\lab\inc\elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf	access:public
e_machine	.\lab\inc\elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf	access:public
e_magic	.\lab\inc\elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf	access:public
e_phentsize	.\lab\inc\elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf	access:public
e_phnum	.\lab\inc\elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf	access:public
e_phoff	.\lab\inc\elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf	access:public
e_shentsize	.\lab\inc\elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf	access:public
e_shnum	.\lab\inc\elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf	access:public
e_shoff	.\lab\inc\elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf	access:public
e_shstrndx	.\lab\inc\elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf	access:public
e_type	.\lab\inc\elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf	access:public
e_version	.\lab\inc\elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf	access:public
ebuf	.\lab\lib\printfmt.c	/^	char *ebuf;$/;"	m	struct:sprintbuf	file:	access:public
eip_file	.\lab\kern\kdebug.h	/^	const char *eip_file;		\/\/ Source code filename for EIP$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_addr	.\lab\kern\kdebug.h	/^	uintptr_t eip_fn_addr;		\/\/ Address of start of function$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_name	.\lab\kern\kdebug.h	/^	const char *eip_fn_name;	\/\/ Name of function containing EIP$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_namelen	.\lab\kern\kdebug.h	/^	int eip_fn_namelen;		\/\/ Length of function name$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_narg	.\lab\kern\kdebug.h	/^	int eip_fn_narg;		\/\/ Number of function arguments$/;"	m	struct:Eipdebuginfo	access:public
eip_line	.\lab\kern\kdebug.h	/^	int eip_line;			\/\/ Source code linenumber for EIP$/;"	m	struct:Eipdebuginfo	access:public
end_part	.\lab\gradelib.py	/^def end_part(name):$/;"	f	access:public
entry	.\lab\kern\entry.S	/^entry:$/;"	l
entry_pgdir	.\lab\kern\entrypgdir.c	/^pde_t entry_pgdir[NPDENTRIES] = {$/;"	v
entry_pgtable	.\lab\kern\entrypgdir.c	/^pte_t entry_pgtable[NPTENTRIES] = {$/;"	v
entry_pgtable	.\lab\kern\entrypgdir.c	/^pte_t entry_pgtable[NPTENTRIES];$/;"	v
errno	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
error_string	.\lab\lib\printfmt.c	/^static const char * const error_string[MAXERROR] =$/;"	v	file:
false	.\lab\inc\types.h	/^enum { false, true };$/;"	e	enum:__anon2
fileno	.\lab\gradelib.py	/^    def fileno(self):$/;"	f	access:public
fileno	.\lab\gradelib.py	/^    def fileno(self):$/;"	m	class:GDBClient	access:public
fprintf	.\lab\inc\stdio.h	/^int	fprintf(int fd, const char *fmt, ...);$/;"	p	signature:(int fd, const char *fmt, ...)
fs_test	.\lab\fs\test.c	/^fs_test(void)$/;"	f	signature:(void)
func	.\lab\kern\monitor.c	/^	int (*func)(int argc, char** argv, struct Trapframe* tf);$/;"	m	struct:Command	file:	access:public
gd_args	.\lab\inc\mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc	access:public
gd_dpl	.\lab\inc\mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc	access:public
gd_off_15_0	.\lab\inc\mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc	access:public
gd_off_31_16	.\lab\inc\mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc	access:public
gd_p	.\lab\inc\mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc	access:public
gd_rsv1	.\lab\inc\mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc	access:public
gd_s	.\lab\inc\mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc	access:public
gd_sel	.\lab\inc\mmu.h	/^	unsigned gd_sel : 16;        \/\/ segment selector$/;"	m	struct:Gatedesc	access:public
gd_type	.\lab\inc\mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc	access:public
gdt	.\lab\boot\boot.S	/^gdt:$/;"	l
gdtdesc	.\lab\boot\boot.S	/^gdtdesc:$/;"	l
get_current_test	.\lab\gradelib.py	/^def get_current_test():$/;"	f	access:public
get_gdb_port	.\lab\gradelib.py	/^    def get_gdb_port():$/;"	f	access:public
getchar	.\lab\inc\stdio.h	/^int	getchar(void);$/;"	p	signature:(void)
getchar	.\lab\kern\console.c	/^getchar(void)$/;"	f	signature:(void)
getint	.\lab\lib\printfmt.c	/^getint(va_list *ap, int lflag)$/;"	f	file:	signature:(va_list *ap, int lflag)
getuint	.\lab\lib\printfmt.c	/^getuint(va_list *ap, int lflag)$/;"	f	file:	signature:(va_list *ap, int lflag)
handle_output	.\lab\gradelib.py	/^        def handle_output(output):$/;"	f	function:call_on_line.setup_call_on_line	access:public
handle_read	.\lab\gradelib.py	/^    def handle_read(self):$/;"	f	access:public
handle_read	.\lab\gradelib.py	/^    def handle_read(self):$/;"	m	class:GDBClient	access:public
i386_init	.\lab\kern\init.c	/^i386_init(void)$/;"	f	signature:(void)
inb	.\lab\inc\x86.h	/^inb(int port)$/;"	f	signature:(int port)
inl	.\lab\inc\x86.h	/^inl(int port)$/;"	f	signature:(int port)
insb	.\lab\inc\x86.h	/^insb(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insl	.\lab\inc\x86.h	/^insl(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insw	.\lab\inc\x86.h	/^insw(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
int16_t	.\lab\inc\types.h	/^typedef short int16_t;$/;"	t
int32_t	.\lab\inc\types.h	/^typedef int int32_t;$/;"	t
int64_t	.\lab\inc\types.h	/^typedef long long int64_t;$/;"	t
int8_t	.\lab\inc\types.h	/^typedef __signed char int8_t;$/;"	t
intptr_t	.\lab\inc\types.h	/^typedef int32_t intptr_t;$/;"	t
invlpg	.\lab\inc\x86.h	/^invlpg(void *addr)$/;"	f	signature:(void *addr)
inw	.\lab\inc\x86.h	/^inw(int port)$/;"	f	signature:(int port)
iscons	.\lab\inc\stdio.h	/^int	iscons(int fd);$/;"	p	signature:(int fd)
iscons	.\lab\kern\console.c	/^iscons(int fdnum)$/;"	f	signature:(int fdnum)
kbd_init	.\lab\kern\console.c	/^kbd_init(void)$/;"	f	file:	signature:(void)
kbd_intr	.\lab\kern\console.c	/^kbd_intr(void)$/;"	f	signature:(void)
kbd_intr	.\lab\kern\console.h	/^void kbd_intr(void); \/\/ irq 1$/;"	p	signature:(void)
kbd_proc_data	.\lab\kern\console.c	/^kbd_proc_data(void)$/;"	f	file:	signature:(void)
kill	.\lab\gradelib.py	/^    def kill(self):$/;"	f	access:public
lcr0	.\lab\inc\x86.h	/^lcr0(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr3	.\lab\inc\x86.h	/^lcr3(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr4	.\lab\inc\x86.h	/^lcr4(uint32_t val)$/;"	f	signature:(uint32_t val)
lgdt	.\lab\inc\x86.h	/^lgdt(void *p)$/;"	f	signature:(void *p)
lidt	.\lab\inc\x86.h	/^lidt(void *p)$/;"	f	signature:(void *p)
lldt	.\lab\inc\x86.h	/^lldt(uint16_t sel)$/;"	f	signature:(uint16_t sel)
lpt_putc	.\lab\kern\console.c	/^lpt_putc(int c)$/;"	f	file:	signature:(int c)
ltr	.\lab\inc\x86.h	/^ltr(uint16_t sel)$/;"	f	signature:(uint16_t sel)
make	.\lab\gradelib.py	/^def make(*target):$/;"	f	access:public
match	.\lab\gradelib.py	/^    def match(self, *args, **kwargs):$/;"	m	class:Runner	access:public
maybe_unlink	.\lab\gradelib.py	/^def maybe_unlink(*paths):$/;"	f	access:public
memcmp	.\lab\inc\string.h	/^int	memcmp(const void *s1, const void *s2, size_t len);$/;"	p	signature:(const void *s1, const void *s2, size_t len)
memcmp	.\lab\lib\string.c	/^memcmp(const void *v1, const void *v2, size_t n)$/;"	f	signature:(const void *v1, const void *v2, size_t n)
memcpy	.\lab\inc\string.h	/^void *	memcpy(void *dst, const void *src, size_t len);$/;"	p	signature:(void *dst, const void *src, size_t len)
memcpy	.\lab\lib\string.c	/^memcpy(void *dst, const void *src, size_t n)$/;"	f	signature:(void *dst, const void *src, size_t n)
memfind	.\lab\inc\string.h	/^void *	memfind(const void *s, int c, size_t len);$/;"	p	signature:(const void *s, int c, size_t len)
memfind	.\lab\lib\string.c	/^memfind(const void *s, int c, size_t n)$/;"	f	signature:(const void *s, int c, size_t n)
memmove	.\lab\inc\string.h	/^void *	memmove(void *dst, const void *src, size_t len);$/;"	p	signature:(void *dst, const void *src, size_t len)
memmove	.\lab\lib\string.c	/^memmove(void *dst, const void *src, size_t n)$/;"	f	signature:(void *dst, const void *src, size_t n)
memset	.\lab\inc\string.h	/^void *	memset(void *dst, int c, size_t len);$/;"	p	signature:(void *dst, int c, size_t len)
memset	.\lab\lib\string.c	/^memset(void *v, int c, size_t n)$/;"	f	signature:(void *v, int c, size_t n)
mon_backtrace	.\lab\kern\monitor.c	/^mon_backtrace(int argc, char **argv, struct Trapframe *tf)$/;"	f	signature:(int argc, char **argv, struct Trapframe *tf)
mon_backtrace	.\lab\kern\monitor.h	/^int mon_backtrace(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
mon_help	.\lab\kern\monitor.c	/^mon_help(int argc, char **argv, struct Trapframe *tf)$/;"	f	signature:(int argc, char **argv, struct Trapframe *tf)
mon_help	.\lab\kern\monitor.h	/^int mon_help(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
mon_kerninfo	.\lab\kern\monitor.c	/^mon_kerninfo(int argc, char **argv, struct Trapframe *tf)$/;"	f	signature:(int argc, char **argv, struct Trapframe *tf)
mon_kerninfo	.\lab\kern\monitor.h	/^int mon_kerninfo(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
monitor	.\lab\kern\monitor.c	/^monitor(struct Trapframe *tf)$/;"	f	signature:(struct Trapframe *tf)
monitor	.\lab\kern\monitor.h	/^void monitor(struct Trapframe *tf);$/;"	p	signature:(struct Trapframe *tf)
msg	.\lab\fs\test.c	/^static char *msg = "This is the NEW message of the day!\\n\\n";$/;"	v	file:
n_desc	.\lab\inc\stab.h	/^	uint16_t n_desc;        \/\/ description field$/;"	m	struct:Stab	access:public
n_other	.\lab\inc\stab.h	/^	uint8_t n_other;        \/\/ misc info (usually empty)$/;"	m	struct:Stab	access:public
n_strx	.\lab\inc\stab.h	/^	uint32_t n_strx;	\/\/ index into string table of name$/;"	m	struct:Stab	access:public
n_type	.\lab\inc\stab.h	/^	uint8_t n_type;         \/\/ type of symbol$/;"	m	struct:Stab	access:public
n_value	.\lab\inc\stab.h	/^	uintptr_t n_value;	\/\/ value of symbol$/;"	m	struct:Stab	access:public
name	.\lab\kern\monitor.c	/^	const char *name;$/;"	m	struct:Command	file:	access:public
normalmap	.\lab\kern\console.c	/^static uint8_t normalmap[256] =$/;"	v	file:
off_t	.\lab\inc\types.h	/^typedef int32_t off_t;$/;"	t
offsetof	.\lab\inc\types.h	73;"	d
os	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
outb	.\lab\inc\x86.h	/^outb(int port, uint8_t data)$/;"	f	signature:(int port, uint8_t data)
outl	.\lab\inc\x86.h	/^outl(int port, uint32_t data)$/;"	f	signature:(int port, uint32_t data)
outsb	.\lab\inc\x86.h	/^outsb(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsl	.\lab\inc\x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsw	.\lab\inc\x86.h	/^outsw(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outw	.\lab\inc\x86.h	/^outw(int port, uint16_t data)$/;"	f	signature:(int port, uint16_t data)
p_align	.\lab\inc\elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr	access:public
p_filesz	.\lab\inc\elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr	access:public
p_flags	.\lab\inc\elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr	access:public
p_memsz	.\lab\inc\elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr	access:public
p_offset	.\lab\inc\elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr	access:public
p_pa	.\lab\inc\elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr	access:public
p_type	.\lab\inc\elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr	access:public
p_va	.\lab\inc\elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr	access:public
panic	.\lab\inc\assert.h	12;"	d
panicstr	.\lab\kern\init.c	/^const char *panicstr;$/;"	v
pd_base	.\lab\inc\mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc	access:public
pd_lim	.\lab\inc\mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc	access:public
pde_t	.\lab\inc\memlayout.h	/^typedef uint32_t pde_t;$/;"	t
physaddr_t	.\lab\inc\types.h	/^typedef uint32_t physaddr_t;$/;"	t
post_make	.\lab\gradelib.py	/^def post_make():$/;"	f	access:public
ppn_t	.\lab\inc\types.h	/^typedef uint32_t ppn_t;$/;"	t
pre_make	.\lab\gradelib.py	/^def pre_make():$/;"	f	access:public
print_function	.\lab\gradelib.py	/^from __future__ import print_function$/;"	i
printf	.\lab\inc\stdio.h	/^int	printf(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
printfmt	.\lab\inc\stdio.h	/^void	printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);$/;"	p	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
printfmt	.\lab\lib\printfmt.c	/^printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)$/;"	f	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
printfmt	.\lab\lib\printfmt.c	/^void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);$/;"	p	file:	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
printnum	.\lab\lib\printfmt.c	/^printnum(void (*putch)(int, void*), void *putdat,$/;"	f	file:	signature:(void (*putch)(int, void*), void *putdat, unsigned long long num, unsigned base, int width, int padc)
protcseg	.\lab\boot\boot.S	/^protcseg:$/;"	l
pte_t	.\lab\inc\memlayout.h	/^typedef uint32_t pte_t;$/;"	t
putch	.\lab\kern\printf.c	/^putch(int ch, int *cnt)$/;"	f	file:	signature:(int ch, int *cnt)
quote	.\lab\gradelib.py	/^    from pipes import quote$/;"	i
rcr0	.\lab\inc\x86.h	/^rcr0(void)$/;"	f	signature:(void)
rcr2	.\lab\inc\x86.h	/^rcr2(void)$/;"	f	signature:(void)
rcr3	.\lab\inc\x86.h	/^rcr3(void)$/;"	f	signature:(void)
rcr4	.\lab\inc\x86.h	/^rcr4(void)$/;"	f	signature:(void)
re	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
read_ebp	.\lab\inc\x86.h	/^read_ebp(void)$/;"	f	signature:(void)
read_eflags	.\lab\inc\x86.h	/^read_eflags(void)$/;"	f	signature:(void)
read_esp	.\lab\inc\x86.h	/^read_esp(void)$/;"	f	signature:(void)
read_tsc	.\lab\inc\x86.h	/^read_tsc(void)$/;"	f	signature:(void)
readdeps	.\lab\mergedep.pl	/^sub readdeps {$/;"	s
readline	.\lab\inc\stdio.h	/^char*	readline(const char *prompt);$/;"	p	signature:(const char *prompt)
readline	.\lab\lib\readline.c	/^readline(const char *prompt)$/;"	f	signature:(const char *prompt)
readsect	.\lab\boot\main.c	/^readsect(void *dst, uint32_t offset)$/;"	f	signature:(void *dst, uint32_t offset)
readsect	.\lab\boot\main.c	/^void readsect(void*, uint32_t);$/;"	p	file:	signature:(void*, uint32_t)
readseg	.\lab\boot\main.c	/^readseg(uint32_t pa, uint32_t count, uint32_t offset)$/;"	f	signature:(uint32_t pa, uint32_t count, uint32_t offset)
readseg	.\lab\boot\main.c	/^void readseg(uint32_t, uint32_t, uint32_t);$/;"	p	file:
register_test	.\lab\gradelib.py	/^    def register_test(fn, title=title):$/;"	f	function:test	access:public
relocated	.\lab\kern\entry.S	/^relocated:$/;"	l
reset_fs	.\lab\gradelib.py	/^def reset_fs():$/;"	f	access:public
rpos	.\lab\kern\console.c	/^	uint32_t rpos;$/;"	m	struct:__anon3	file:	access:public
run_qemu	.\lab\gradelib.py	/^    def run_qemu(self, *monitors, **kw):$/;"	m	class:Runner	access:public
run_qemu_kw	.\lab\gradelib.py	/^        def run_qemu_kw(target_base="qemu", make_args=[], timeout=30):$/;"	f	function:Runner.run_qemu	access:public
run_test	.\lab\gradelib.py	/^        def run_test():$/;"	f	function:test.register_test	access:public
run_tests	.\lab\gradelib.py	/^def run_tests():$/;"	f	access:public
runcmd	.\lab\kern\monitor.c	/^runcmd(char *buf, struct Trapframe *tf)$/;"	f	file:	signature:(char *buf, struct Trapframe *tf)
save	.\lab\gradelib.py	/^def save(path):$/;"	f	access:public
save_on_finish	.\lab\gradelib.py	/^    def save_on_finish(fail):$/;"	f	function:save	access:public
sd_avl	.\lab\inc\mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc	access:public
sd_base_15_0	.\lab\inc\mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_base_23_16	.\lab\inc\mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_base_31_24	.\lab\inc\mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_db	.\lab\inc\mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc	access:public
sd_dpl	.\lab\inc\mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc	access:public
sd_g	.\lab\inc\mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc	access:public
sd_lim_15_0	.\lab\inc\mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc	access:public
sd_lim_19_16	.\lab\inc\mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc	access:public
sd_p	.\lab\inc\mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc	access:public
sd_rsv1	.\lab\inc\mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc	access:public
sd_s	.\lab\inc\mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc	access:public
sd_type	.\lab\inc\mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc	access:public
select	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
serial_exists	.\lab\kern\console.c	/^static bool serial_exists;$/;"	v	file:
serial_init	.\lab\kern\console.c	/^serial_init(void)$/;"	f	file:	signature:(void)
serial_intr	.\lab\kern\console.c	/^serial_intr(void)$/;"	f	signature:(void)
serial_intr	.\lab\kern\console.h	/^void serial_intr(void); \/\/ irq 4$/;"	p	signature:(void)
serial_proc_data	.\lab\kern\console.c	/^serial_proc_data(void)$/;"	f	file:	signature:(void)
serial_putc	.\lab\kern\console.c	/^serial_putc(int c)$/;"	f	file:	signature:(int c)
setup_breakpoint	.\lab\gradelib.py	/^    def setup_breakpoint(runner):$/;"	f	function:stop_breakpoint	access:public
setup_call_on_line	.\lab\gradelib.py	/^    def setup_call_on_line(runner):$/;"	f	function:call_on_line	access:public
setup_save	.\lab\gradelib.py	/^    def setup_save(runner):$/;"	f	function:save	access:public
sh_addr	.\lab\inc\elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr	access:public
sh_addralign	.\lab\inc\elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr	access:public
sh_entsize	.\lab\inc\elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr	access:public
sh_flags	.\lab\inc\elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr	access:public
sh_info	.\lab\inc\elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr	access:public
sh_link	.\lab\inc\elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr	access:public
sh_name	.\lab\inc\elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr	access:public
sh_offset	.\lab\inc\elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr	access:public
sh_size	.\lab\inc\elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr	access:public
sh_type	.\lab\inc\elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr	access:public
shiftcode	.\lab\kern\console.c	/^static uint8_t shiftcode[256] =$/;"	v	file:
shiftmap	.\lab\kern\console.c	/^static uint8_t shiftmap[256] =$/;"	v	file:
show_command	.\lab\gradelib.py	/^def show_command(cmd):$/;"	f	access:public
show_part	.\lab\gradelib.py	/^    def show_part():$/;"	f	function:end_part	access:public
shutil	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
size_t	.\lab\inc\types.h	/^typedef uint32_t size_t;$/;"	t
snprintf	.\lab\inc\stdio.h	/^int	snprintf(char *str, int size, const char *fmt, ...);$/;"	p	signature:(char *str, int size, const char *fmt, ...)
snprintf	.\lab\lib\printfmt.c	/^snprintf(char *buf, int n, const char *fmt, ...)$/;"	f	signature:(char *buf, int n, const char *fmt, ...)
socket	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
spin	.\lab\boot\boot.S	/^spin:$/;"	l
spin	.\lab\kern\entry.S	/^spin:	jmp	spin$/;"	l
sprintbuf	.\lab\lib\printfmt.c	/^struct sprintbuf {$/;"	s	file:
sprintbuf::buf	.\lab\lib\printfmt.c	/^	char *buf;$/;"	m	struct:sprintbuf	file:	access:public
sprintbuf::cnt	.\lab\lib\printfmt.c	/^	int cnt;$/;"	m	struct:sprintbuf	file:	access:public
sprintbuf::ebuf	.\lab\lib\printfmt.c	/^	char *ebuf;$/;"	m	struct:sprintbuf	file:	access:public
sprintputch	.\lab\lib\printfmt.c	/^sprintputch(int ch, struct sprintbuf *b)$/;"	f	file:	signature:(int ch, struct sprintbuf *b)
ssize_t	.\lab\inc\types.h	/^typedef int32_t ssize_t;$/;"	t
stab_binsearch	.\lab\kern\kdebug.c	/^stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,$/;"	f	file:	signature:(const struct Stab *stabs, int *region_left, int *region_right, int type, uintptr_t addr)
start	.\lab\boot\boot.S	/^start:$/;"	l
static_assert	.\lab\inc\assert.h	18;"	d
stop	.\lab\gradelib.py	/^    def stop(line):$/;"	f	function:stop_on_line	access:public
stop_breakpoint	.\lab\gradelib.py	/^def stop_breakpoint(addr):$/;"	f	access:public
stop_on_line	.\lab\gradelib.py	/^def stop_on_line(regexp):$/;"	f	access:public
str1	.\lab\user\sendpage.c	/^const char *str1 = "hello child environment! how are you?";$/;"	v
str2	.\lab\user\sendpage.c	/^const char *str2 = "hello parent environment! I'm good.";$/;"	v
strcat	.\lab\inc\string.h	/^char *	strcat(char *dst, const char *src);$/;"	p	signature:(char *dst, const char *src)
strcat	.\lab\lib\string.c	/^strcat(char *dst, const char *src)$/;"	f	signature:(char *dst, const char *src)
strchr	.\lab\inc\string.h	/^char *	strchr(const char *s, char c);$/;"	p	signature:(const char *s, char c)
strchr	.\lab\lib\string.c	/^strchr(const char *s, char c)$/;"	f	signature:(const char *s, char c)
strcmp	.\lab\inc\string.h	/^int	strcmp(const char *s1, const char *s2);$/;"	p	signature:(const char *s1, const char *s2)
strcmp	.\lab\lib\string.c	/^strcmp(const char *p, const char *q)$/;"	f	signature:(const char *p, const char *q)
strcpy	.\lab\inc\string.h	/^char *	strcpy(char *dst, const char *src);$/;"	p	signature:(char *dst, const char *src)
strcpy	.\lab\lib\string.c	/^strcpy(char *dst, const char *src)$/;"	f	signature:(char *dst, const char *src)
strfind	.\lab\inc\string.h	/^char *	strfind(const char *s, char c);$/;"	p	signature:(const char *s, char c)
strfind	.\lab\lib\string.c	/^strfind(const char *s, char c)$/;"	f	signature:(const char *s, char c)
strlcpy	.\lab\inc\string.h	/^size_t	strlcpy(char *dst, const char *src, size_t size);$/;"	p	signature:(char *dst, const char *src, size_t size)
strlcpy	.\lab\lib\string.c	/^strlcpy(char *dst, const char *src, size_t size)$/;"	f	signature:(char *dst, const char *src, size_t size)
strlen	.\lab\inc\string.h	/^int	strlen(const char *s);$/;"	p	signature:(const char *s)
strlen	.\lab\lib\string.c	/^strlen(const char *s)$/;"	f	signature:(const char *s)
strncmp	.\lab\inc\string.h	/^int	strncmp(const char *s1, const char *s2, size_t size);$/;"	p	signature:(const char *s1, const char *s2, size_t size)
strncmp	.\lab\lib\string.c	/^strncmp(const char *p, const char *q, size_t n)$/;"	f	signature:(const char *p, const char *q, size_t n)
strncpy	.\lab\inc\string.h	/^char *	strncpy(char *dst, const char *src, size_t size);$/;"	p	signature:(char *dst, const char *src, size_t size)
strncpy	.\lab\lib\string.c	/^strncpy(char *dst, const char *src, size_t size) {$/;"	f	signature:(char *dst, const char *src, size_t size)
strnlen	.\lab\inc\string.h	/^int	strnlen(const char *s, size_t size);$/;"	p	signature:(const char *s, size_t size)
strnlen	.\lab\lib\string.c	/^strnlen(const char *s, size_t size)$/;"	f	signature:(const char *s, size_t size)
strtol	.\lab\inc\string.h	/^long	strtol(const char *s, char **endptr, int base);$/;"	p	signature:(const char *s, char **endptr, int base)
strtol	.\lab\lib\string.c	/^strtol(const char *s, char **endptr, int base)$/;"	f	signature:(const char *s, char **endptr, int base)
subprocess	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
sys	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
test	.\lab\gradelib.py	/^def test(points, title=None, parent=None):$/;"	f	access:public
test_backtrace	.\lab\kern\init.c	/^test_backtrace(int x)$/;"	f	signature:(int x)
time	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
tlbflush	.\lab\inc\x86.h	/^tlbflush(void)$/;"	f	signature:(void)
togglecode	.\lab\kern\console.c	/^static uint8_t togglecode[256] =$/;"	v	file:
traceback	.\lab\gradelib.py	/^import sys, os, re, time, socket, select, subprocess, errno, shutil, traceback$/;"	i
true	.\lab\inc\types.h	/^enum { false, true };$/;"	e	enum:__anon2
ts_cr3	.\lab\inc\mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate	access:public
ts_cs	.\lab\inc\mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate	access:public
ts_ds	.\lab\inc\mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate	access:public
ts_eax	.\lab\inc\mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate	access:public
ts_ebp	.\lab\inc\mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate	access:public
ts_ebx	.\lab\inc\mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate	access:public
ts_ecx	.\lab\inc\mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate	access:public
ts_edi	.\lab\inc\mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate	access:public
ts_edx	.\lab\inc\mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate	access:public
ts_eflags	.\lab\inc\mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate	access:public
ts_eip	.\lab\inc\mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate	access:public
ts_es	.\lab\inc\mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate	access:public
ts_esi	.\lab\inc\mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate	access:public
ts_esp	.\lab\inc\mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate	access:public
ts_esp0	.\lab\inc\mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate	access:public
ts_esp1	.\lab\inc\mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate	access:public
ts_esp2	.\lab\inc\mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate	access:public
ts_fs	.\lab\inc\mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate	access:public
ts_gs	.\lab\inc\mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate	access:public
ts_iomb	.\lab\inc\mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate	access:public
ts_ldt	.\lab\inc\mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate	access:public
ts_link	.\lab\inc\mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate	access:public
ts_padding1	.\lab\inc\mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate	access:public
ts_padding10	.\lab\inc\mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate	access:public
ts_padding2	.\lab\inc\mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate	access:public
ts_padding3	.\lab\inc\mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate	access:public
ts_padding4	.\lab\inc\mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate	access:public
ts_padding5	.\lab\inc\mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate	access:public
ts_padding6	.\lab\inc\mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate	access:public
ts_padding7	.\lab\inc\mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate	access:public
ts_padding8	.\lab\inc\mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate	access:public
ts_padding9	.\lab\inc\mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate	access:public
ts_ss	.\lab\inc\mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate	access:public
ts_ss0	.\lab\inc\mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate	access:public
ts_ss1	.\lab\inc\mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate	access:public
ts_ss2	.\lab\inc\mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate	access:public
ts_t	.\lab\inc\mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate	access:public
uint16_t	.\lab\inc\types.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	.\lab\inc\types.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	.\lab\inc\types.h	/^typedef unsigned long long uint64_t;$/;"	t
uint8_t	.\lab\inc\types.h	/^typedef unsigned char uint8_t;$/;"	t
uintptr_t	.\lab\inc\types.h	/^typedef uint32_t uintptr_t;$/;"	t
umain	.\lab\user\sendpage.c	/^umain(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
user_test	.\lab\gradelib.py	/^    def user_test(self, binary, *monitors, **kw):$/;"	m	class:Runner	access:public
va_arg	.\lab\inc\stdarg.h	10;"	d
va_end	.\lab\inc\stdarg.h	12;"	d
va_list	.\lab\inc\stdarg.h	/^typedef __builtin_va_list va_list;$/;"	t
va_start	.\lab\inc\stdarg.h	8;"	d
vcprintf	.\lab\inc\stdio.h	/^int	vcprintf(const char *fmt, va_list);$/;"	p	signature:(const char *fmt, va_list)
vcprintf	.\lab\kern\printf.c	/^vcprintf(const char *fmt, va_list ap)$/;"	f	signature:(const char *fmt, va_list ap)
vfprintf	.\lab\inc\stdio.h	/^int	vfprintf(int fd, const char *fmt, va_list);$/;"	p	signature:(int fd, const char *fmt, va_list)
vprintfmt	.\lab\inc\stdio.h	/^void	vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list);$/;"	p	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, va_list)
vprintfmt	.\lab\lib\printfmt.c	/^vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)$/;"	f	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
vsnprintf	.\lab\inc\stdio.h	/^int	vsnprintf(char *str, int size, const char *fmt, va_list);$/;"	p	signature:(char *str, int size, const char *fmt, va_list)
vsnprintf	.\lab\lib\printfmt.c	/^vsnprintf(char *buf, int n, const char *fmt, va_list ap)$/;"	f	signature:(char *buf, int n, const char *fmt, va_list ap)
wait	.\lab\gradelib.py	/^    def wait(self):$/;"	f	access:public
waitdisk	.\lab\boot\main.c	/^waitdisk(void)$/;"	f	signature:(void)
warn	.\lab\inc\assert.h	11;"	d
wpos	.\lab\kern\console.c	/^	uint32_t wpos;$/;"	m	struct:__anon3	file:	access:public
write_eflags	.\lab\inc\x86.h	/^write_eflags(uint32_t eflags)$/;"	f	signature:(uint32_t eflags)
xchg	.\lab\inc\x86.h	/^xchg(volatile uint32_t *addr, uint32_t newval)$/;"	f	signature:(volatile uint32_t *addr, uint32_t newval)
